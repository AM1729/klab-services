package org.integratedmodelling.klab.services.resources.storage;import com.google.common.collect.Sets;import com.google.inject.Inject;import com.google.inject.Injector;import org.eclipse.emf.ecore.EObject;import org.eclipse.emf.ecore.EStructuralFeature;import org.eclipse.xtext.parser.IParseResult;import org.eclipse.xtext.parser.IParser;import org.integratedmodelling.common.knowledge.ProjectImpl;import org.integratedmodelling.common.knowledge.WorkspaceImpl;import org.integratedmodelling.common.knowledge.WorldviewImpl;import org.integratedmodelling.klab.api.Klab;import org.integratedmodelling.klab.api.authentication.CRUDOperation;import org.integratedmodelling.klab.api.authentication.ResourcePrivileges;import org.integratedmodelling.klab.api.collections.Pair;import org.integratedmodelling.klab.api.collections.Triple;import org.integratedmodelling.klab.api.data.Metadata;import org.integratedmodelling.klab.api.data.Repository;import org.integratedmodelling.klab.api.data.Version;import org.integratedmodelling.klab.api.exceptions.KlabAuthorizationException;import org.integratedmodelling.klab.api.exceptions.KlabIllegalStateException;import org.integratedmodelling.klab.api.exceptions.KlabResourceAccessException;import org.integratedmodelling.klab.api.exceptions.KlabUnimplementedException;import org.integratedmodelling.klab.api.knowledge.KlabAsset;import org.integratedmodelling.klab.api.knowledge.SemanticType;import org.integratedmodelling.klab.api.knowledge.Worldview;import org.integratedmodelling.klab.api.knowledge.organization.Project;import org.integratedmodelling.klab.api.knowledge.organization.ProjectStorage;import org.integratedmodelling.klab.api.knowledge.organization.Workspace;import org.integratedmodelling.klab.api.lang.kactors.KActorsBehavior;import org.integratedmodelling.klab.api.lang.kim.*;import org.integratedmodelling.klab.api.scope.Scope;import org.integratedmodelling.klab.api.services.resources.ResourceSet;import org.integratedmodelling.klab.api.services.runtime.Message;import org.integratedmodelling.klab.api.services.runtime.Notification;import org.integratedmodelling.klab.api.services.runtime.impl.NotificationImpl;import org.integratedmodelling.klab.resources.FileProjectStorage;import org.integratedmodelling.klab.services.ServiceStartupOptions;import org.integratedmodelling.klab.services.base.BaseService;import org.integratedmodelling.klab.services.resources.ResourcesProvider;import org.integratedmodelling.klab.services.resources.configuration.ResourcesConfiguration;import org.integratedmodelling.klab.services.resources.lang.LanguageAdapter;import org.integratedmodelling.klab.services.resources.lang.WorldviewValidationScope;import org.integratedmodelling.klab.utilities.Utils;import org.integratedmodelling.languages.*;import org.integratedmodelling.languages.api.*;import org.integratedmodelling.languages.kim.Model;import org.integratedmodelling.languages.observable.ConceptExpression;import org.integratedmodelling.languages.observable.ObservableSemantics;import org.integratedmodelling.languages.observable.ObservableSequence;import org.integratedmodelling.languages.observation.Strategies;import org.integratedmodelling.languages.services.ObservableGrammarAccess;import org.integratedmodelling.languages.validation.LanguageValidationScope;import org.integratedmodelling.languages.worldview.Ontology;import org.jgrapht.Graph;import org.jgrapht.alg.cycle.CycleDetector;import org.jgrapht.graph.DefaultDirectedGraph;import org.jgrapht.graph.DefaultEdge;import org.jgrapht.traverse.TopologicalOrderIterator;import java.io.*;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.*;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import java.util.function.Function;import static java.util.stream.Collectors.toList;/** * Singleton that separates out all the logics in managing workspaces up to and not including the loading of * the actual knowledge into k.LAB beans. */public class WorkspaceManager {    private final ServiceStartupOptions startupOptions;    private final ResourcesProvider service;    /**     * Default interval to check for changes in Git (15 minutes in milliseconds)     */    private int DEFAULT_GIT_SYNC_INTERVAL_MINUTES = 15;    // project locks are mappings usertoken->projectName and enable remote updating of projects for one    // user at    // a time, while inhibiting file change logging in project storage    private Map<String, String> projectLocks = Collections.synchronizedMap(new HashMap<>());    private AtomicBoolean loading = new AtomicBoolean(false);    private List<Pair<ProjectStorage, Project>> _projectLoadOrder;    private List<KimOntology> _ontologyOrder;    private Map<String, KimOntology> _ontologyMap;    private List<KimNamespace> _namespaceOrder;    private Map<String, KimNamespace> _namespaceMap;    private List<KActorsBehavior> _behaviorOrder;    private Map<String, KActorsBehavior> _behaviorMap;    private List<KimOntology> _worldviewOntologies;    private List<KimObservationStrategy> _observationStrategies;    private List<KimObservationStrategyDocument> _observationStrategyDocuments;    private Map<String, KimObservationStrategyDocument> _observationStrategyDocumentMap;    // all docs that have been loaded through a URL remember the URL keyed by the document URN. No    // guarantee that all URLs correspond to a document in the current catalogs.    private Map<String, URL> documentURLs = new HashMap<>();    private WorldviewImpl _worldview;    //    private AtomicBoolean consistent = new AtomicBoolean(true);    // filled in at boot and maintained when changes happen    private WorldviewValidationScope languageValidationScope;    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);    private boolean worldviewProvider = false;    private String adoptedWorldview;    /**     * This includes the non-local projects, in load order     *     * @return     */    public List<Project> getProjects() {        var ret = new ArrayList<Project>();        for (var project : projects.values()) {            ret.add(updateStatus(project));        }        return ret;    }    public Project getProject(String projectName) {        return projects.get(projectName);    }    private <T extends KlabAsset> T updateStatus(T container) {        if (container instanceof Workspace workspace) {            for (var project : workspace.getProjects()) {                updateProjectStatus(project.getUrn(), null);            }        } else if (container instanceof Project) {            updateProjectStatus(container.getUrn(), null);        } else if (container instanceof KlabDocument<?> document) {            updateProjectStatus(document.getProjectName(), document);        }        return container;    }    private void updateProjectStatus(String projectId, KlabDocument<?> resource) {        var pd = projectDescriptors.get(projectId);        var prj = projects.get(projectId);        if (pd.storage instanceof FileProjectStorage fps) {            fps.updateMetadata(prj, resource, scope);        }    }    public KimConcept.Descriptor describeConcept(String conceptUrn) {        try {            String[] split = conceptUrn.split(":");            var ontology = getOntology(split[0]);            if (ontology != null) {                // we don't cache the concept map, so this is a potentially expensive operation and its                // results should be cached.                var declaration = conceptMap(ontology).get(split[1]);                if (declaration != null) {                    var type = EnumSet.copyOf(declaration.getType());                    type.retainAll(SemanticType.DECLARABLE_TYPES);                    return new KimConcept.Descriptor(declaration.getNamespace(), declaration.getUrn(),                            type.size() == 1 ? type.iterator().next() : SemanticType.NOTHING,                            declaration.getMetadata().get(Metadata.DC_COMMENT, "No description provided"),                            declaration.getMetadata().get(Metadata.DC_LABEL,                                    ontology.getUrn() + ":" + declaration.getUrn()),                            declaration.isAbstract());                }            }        } catch (Throwable throwable) {            // just return null            scope.error(throwable);        }        return null;    }    private Map<String, KimConceptStatement> conceptMap(KimOntology ontology) {        Map<String, KimConceptStatement> ret = new HashMap<>();        for (var conceptStatement : ontology.getStatements()) {            collectConcepts(conceptStatement, ret);        }        return ret;    }    private void collectConcepts(KimConceptStatement conceptStatement, Map<String, KimConceptStatement> ret) {        ret.put(conceptStatement.getUrn(), conceptStatement);        for (var child : conceptStatement.getChildren()) {            collectConcepts(child, ret);        }    }    /**     * Execute the passed operation as an atomic unit, handling any issue. All workspace-modifying operations     * called after initialization should be wrapped in this.     *     * @param runnable     */    private synchronized void atomicOperation(Runnable runnable) {        try {            runnable.run();        } catch (Throwable throwable) {            scope.error(throwable, Klab.ErrorContext.RESOURCES_SERVICE, Klab.ErrorCode.INTERNAL_ERROR);        }    }    public Collection<String> getNamespaceUrns() {        return _namespaceMap == null ? Collections.emptySet() : _namespaceMap.keySet();    }    public Collection<String> getBehaviorUrns() {        return _behaviorMap == null ? Collections.emptySet() : _behaviorMap.keySet();    }    public URL lockProject(String urn, String token, boolean isLocal) {        var descriptor = projectDescriptors.get(urn);        if (descriptor == null || !(descriptor.storage instanceof FileProjectStorage)) {            return null;        }        // check and record lock        if (projectLocks.containsKey(urn) && !projectLocks.get(urn).equals(token)) {            scope.info("Lock attempt failed: project " + urn + " is already locked");            return null;        }        projectLocks.put(urn, token);        ((FileProjectStorage) descriptor.storage).lock(true);        scope.info("Project " + urn + " is locked");        if (isLocal) {            return descriptor.storage.getUrl();        } else {            // TODO prepare a zip file and make it available through download area, return public URL        }        return null;    }    public boolean unlockProject(String urn, String token) {        if (projectLocks.containsKey(urn)) {            if (projectLocks.get(urn).equals(token)) {                var descriptor = projectDescriptors.get(urn);                ((FileProjectStorage) descriptor.storage).lock(false);                projectLocks.remove(urn);                scope.info("Project " + urn + " unlocked");                return true;            }        }        return false;    }    public boolean isWorldviewProvider() {        return this.worldviewProvider;    }    public String getAdoptedWorldview() {        return this.adoptedWorldview;    }    public List<ResourceSet> manageRepository(String projectName, Repository.Operation operation,                                              String[] arguments) {        var pd = projectDescriptors.get(projectName);        if (pd != null && pd.storage instanceof FileProjectStorage fileProjectStorage) {            var mods = switch (operation) {                case FETCH_COMMIT_AND_PUSH ->                        Utils.Git.fetchCommitAndPush(fileProjectStorage.getRootFolder(),                                arguments == null || arguments.length == 0 ? "Committed by k.LAB resources " +                                        "service" : arguments[0], scope);                case FETCH_AND_MERGE -> Utils.Git.fetchAndMerge(fileProjectStorage.getRootFolder());                case COMMIT_AND_SWITCH ->                        Utils.Git.commitAndSwitch(fileProjectStorage.getRootFolder(), arguments[0]);                case HARD_RESET -> Utils.Git.hardReset(fileProjectStorage.getRootFolder());                case MERGE_CHANGES_FROM -> Utils.Git.mergeChangesFrom(fileProjectStorage.getRootFolder(), arguments[0]);            };            List<Triple<ProjectStorage.ResourceType, CRUDOperation, URL>> changes = new ArrayList<>();            for (var path : mods.getRemovedPaths()) {                System.out.println("DIOCANE " + path);            }            for (var path : mods.getAddedPaths()) {                System.out.println("DIOBOIA " + path);            }            for (var path : mods.getModifiedPaths()) {                System.out.println("DIOCULO " + path);            }            return changes.isEmpty() ? List.of() : handleFileChange(projectName, changes);        }        return List.of(ResourceSet.empty(Notification.create("Project" + projectName + " not found or not " +                "accessible", Notification.Level.Error)));    }    class StrategyParser extends Parser<Strategies> {        @Override        protected Injector createInjector() {            return new ObservationStandaloneSetup().createInjectorAndDoEMFRegistration();        }        /**         * Parse a concept definition into its syntactic peer, which should be inspected for errors before         * turning into semantics.         *         * @param strategyUrl         * @return the parsed semantic expression, or null if the parser cannot make sense of it.         */        public ObservationStrategiesSyntax parseStrategies(URL strategyUrl, String projectName) {            List<Notification> errors = new ArrayList<>();            try (var input = strategyUrl.openStream()) {                var result = parse(input, errors);                if (!errors.isEmpty()) {                    for (var error : errors) {                        scope.error("Observation strategy resource has errors: " + strategyUrl,                                Klab.ErrorCode.RESOURCE_VALIDATION, Klab.ErrorContext.OBSERVATION_STRATEGY);                    }                    return null;                }                if (result instanceof Strategies strategies) {                    String strategyUrn = projectName + "." + Utils.URLs.getURLBaseName(strategyUrl) +                            ".strategies";                    return new ObservationStrategiesSyntaxImpl(strategyUrn, strategies,                            languageValidationScope) {                        @Override                        protected void logWarning(ParsedObject target, EObject object,                                                  EStructuralFeature feature, String message) {                            getNotifications().add(new Notification(object,                                    new LanguageValidationScope.ValidationMessage(message, -1,                                            LanguageValidationScope.Level.WARNING)));                        }                        @Override                        protected void logError(ParsedObject target, EObject object,                                                EStructuralFeature feature, String message) {                            getNotifications().add(new Notification(object,                                    new LanguageValidationScope.ValidationMessage(message, -1,                                            LanguageValidationScope.Level.ERROR)));                        }                    };                }            } catch (IOException e) {                scope.error("Error loading observation strategy " + strategyUrl, Klab.ErrorCode.READ_FAILED                        , Klab.ErrorContext.OBSERVATION_STRATEGY);            }            return null;        }    }    class ObservableParser extends Parser<ObservableSequence> {        @Inject        ObservableGrammarAccess grammarAccess;        @Override        protected Injector createInjector() {            return new ObservableStandaloneSetup().createInjectorAndDoEMFRegistration();        }        /**         * Parse a concept definition into its syntactic peer, which should be inspected for errors before         * turning into semantics.         *         * @param conceptDefinition         * @return the parsed semantic expression, or null if the parser cannot make sense of it.         */        public SemanticSyntax parseConcept(String conceptDefinition) {            var result = parser.parse(grammarAccess.getConceptExpressionRule(),                    new StringReader(conceptDefinition));            var ret = result.getRootASTElement();            if (ret instanceof ConceptExpression) {                return new SemanticSyntaxImpl((ConceptExpression) ret, languageValidationScope) {                    List<String> errors = new ArrayList<>();                    @Override                    protected void logWarning(ParsedObject target, EObject object,                                              EStructuralFeature feature, String message) {                        getNotifications().add(new Notification(object,                                new LanguageValidationScope.ValidationMessage(message, -1,                                        LanguageValidationScope.Level.WARNING)));                    }                    @Override                    protected void logError(ParsedObject target, EObject object, EStructuralFeature feature                            , String message) {                        getNotifications().add(new Notification(object,                                new LanguageValidationScope.ValidationMessage(message, -1,                                        LanguageValidationScope.Level.ERROR)));                    }                };            }            return null;        }        /**         * Parse an observable definition into its syntactic peer, which should be inspected for errors before         * turning into semantics.         *         * @param observableDefinition         * @return the parsed semantic expression, or null if the parser cannot make sense of it.         */        public ObservableSyntax parseObservable(String observableDefinition) {            var result = parser.parse(grammarAccess.getObservableSemanticsRule(),                    new StringReader(observableDefinition));            var ret = result.getRootASTElement();            if (ret instanceof ObservableSemantics) {                return new ObservableSyntaxImpl((ObservableSemantics) ret, languageValidationScope) {                    List<String> errors = new ArrayList<>();                    @Override                    protected void logWarning(ParsedObject target, EObject object,                                              EStructuralFeature feature, String message) {                        getNotifications().add(new Notification(object,                                new LanguageValidationScope.ValidationMessage(message, -1,                                        LanguageValidationScope.Level.WARNING)));                    }                    @Override                    protected void logError(ParsedObject target, EObject object, EStructuralFeature feature                            , String message) {                        getNotifications().add(new Notification(object,                                new LanguageValidationScope.ValidationMessage(message, -1,                                        LanguageValidationScope.Level.ERROR)));                    }                };            }            return null;        }    }    private ObservableParser observableParser = new ObservableParser();    private StrategyParser strategyParser = new StrategyParser();    private Parser<Ontology> ontologyParser = new Parser<Ontology>() {        @Override        protected Injector createInjector() {            return new WorldviewStandaloneSetup().createInjectorAndDoEMFRegistration();        }    };    private Parser<Model> namespaceParser = new Parser<Model>() {        @Override        protected Injector createInjector() {            return new KimStandaloneSetup().createInjectorAndDoEMFRegistration();        }    };    private class ProjectDescriptor {        String name;        String workspace;        ProjectStorage storage;        Project externalProject;        Project.Manifest manifest;        int updateInterval;    }    private Map<String, WorkspaceImpl> workspaces = new LinkedHashMap<>();    private final Function<String, Project> externalProjectResolver;    private Map<String, ProjectDescriptor> projectDescriptors = new HashMap<>();    private Map<String, Project> projects = new LinkedHashMap<>();    // all logging goes through here    private Scope scope;    private ResourcesConfiguration configuration;    private Map<String, Long> lastProjectUpdates = new HashMap<>();    private List<Pair<String, Version>> unresolvedProjects = new ArrayList<>();    public WorkspaceManager(Scope scope, ServiceStartupOptions options, ResourcesProvider service,                            Function<String, Project> externalProjectResolver) {        this.service = service;        this.externalProjectResolver = externalProjectResolver;        this.scope = scope;        this.startupOptions = options;        readConfiguration(options);        scheduler.scheduleAtFixedRate(() -> checkForProjectUpdates(), 1, 1, TimeUnit.MINUTES);    }    private void checkForProjectUpdates() {        synchronized (projectDescriptors) {            for (var pd : projectDescriptors.values()) {                // configured interval == 0 disables update                if (pd.storage instanceof FileProjectStorage fpd && !fpd.isLocked() && pd.updateInterval > 0) {                    var now = System.currentTimeMillis();                    var timeToUpdate = lastProjectUpdates.containsKey(pd.name) ?                                       lastProjectUpdates.get(pd.name) + ((long) pd.updateInterval * 1000 * 60) :                                       now;                    if (timeToUpdate <= now) {                        Thread.ofVirtual().start(() -> checkForProjectUpdates(pd));                        lastProjectUpdates.put(pd.name, now);                    }                }            }        }    }    private void checkForProjectUpdates(ProjectDescriptor projectDescriptor) {        // TODO fetch changes and react as configured; if anything must be reloaded, lock the workspace        scope.info("TODO - Checking for updates in unlocked project " + projectDescriptor.name + ", " +                "scheduled each " + projectDescriptor.updateInterval + " minutes");    }    private void readConfiguration(ServiceStartupOptions options) {        File config = BaseService.getFileInConfigurationDirectory(options, "resources.yaml");        if (config.exists() && config.length() > 0 && !options.isClean()) {            this.configuration = org.integratedmodelling.common.utils.Utils.YAML.load(config,                    ResourcesConfiguration.class);        } else {            // make an empty config            this.configuration = new ResourcesConfiguration();            this.configuration.setServicePath("resources");            this.configuration.setLocalResourcePath("local");            this.configuration.setPublicResourcePath("public");            this.configuration.setServiceId(UUID.randomUUID().toString());            saveConfiguration();        }        // clear existing caches (this must be reentrant and be callable again at any new import)        projectDescriptors.clear();        // build descriptors for all locally configured projects and workspaces        for (var workspace : configuration.getWorkspaces().keySet()) {            // ensure existing            if (!this.workspaces.containsKey(workspace)) {                var ws = new WorkspaceImpl();                ws.setUrn(workspace);                this.workspaces.put(workspace, ws);            }            for (var projectName : configuration.getWorkspaces().get(workspace)) {                var projectConfiguration = configuration.getProjectConfiguration().get(projectName);                var storage = switch (projectConfiguration.getStorageType()) {                    case FILE -> new FileProjectStorage(projectConfiguration.getLocalPath(),                            this::handleFileChange);                    // TODO others                    default -> {                        scope.error("Project " + projectName + " cannot be loaded. Configuration is invalid" +                                ".");                        yield null;                    }                };                if (storage != null) {                    var project = loadProject(storage, workspace);                    projects.put(projectName, project);                }            }        }    }    /**     * Return all ontologies sorted in order of dependency. Automatically adapt the local ones from their     * syntactic form. Project dependencies will ensure the consistency of the result; if any of the     * ontologies is part of a missing project, return an empty list.     *     * @param worldviewOnly if true, only ontologies that are part of a project tagged as worldview will be     *                      returned     * @return the fully consistent known worldview or an empty list     */    public List<KimOntology> getOntologies(boolean worldviewOnly) {        if (_ontologyOrder == null) {            _worldviewOntologies = new ArrayList<>();            _ontologyOrder = new ArrayList<>();            _ontologyMap = new HashMap<>();            this.languageValidationScope = new WorldviewValidationScope();            Map<String, String> ontologyProjects = new HashMap<>();            Map<String, Triple<Ontology, KimOntology, Boolean>> cache = new HashMap<>();            Map<String, URL> urlCache = new HashMap<>();            for (var pd : projectDescriptors.values()) {                var isWorldview = pd.manifest.getDefinedWorldview() != null;                if (pd.externalProject != null) {                    for (var ontology : pd.externalProject.getOntologies()) {                        cache.put(ontology.getUrn(), Triple.of(null, ontology, isWorldview));                        // TODO add metadata to the ontology to signify it's remote, probably a URL                    }                } else {                    for (var ontologyUrl : pd.storage.listResources(ProjectStorage.ResourceType.ONTOLOGY)) {                        try (var input = ontologyUrl.openStream()) {                            var errors = new ArrayList<Notification>();                            var parsed = ontologyParser.parse(input, errors);                            if (!errors.isEmpty()) {                                scope.error("Ontology resource has errors: " + ontologyUrl,                                        Klab.ErrorCode.RESOURCE_VALIDATION, Klab.ErrorContext.ONTOLOGY);                                //                                return Collections.emptyList();                            }                            urlCache.put(parsed.getNamespace().getName(), ontologyUrl);                            ontologyProjects.put(parsed.getNamespace().getName(), pd.name);                            cache.put(parsed.getNamespace().getName(), Triple.of(parsed, null, isWorldview));                        } catch (IOException e) {                            // log error and return failure                            scope.error("Error loading ontology " + ontologyUrl, Klab.ErrorCode.READ_FAILED                                    , Klab.ErrorContext.ONTOLOGY);                            //                            return Collections.emptyList();                        }                    }                }            }            // we have the ontologies and there are no errors this far: now build the order and if            // something is unresolved, log error and say goodbye            Graph<String, DefaultEdge> dependencyGraph = new DefaultDirectedGraph<>(DefaultEdge.class);            Map<String, KimOntology> ontologies = new HashMap<>();            for (String ontologyId : cache.keySet()) {                var od = cache.get(ontologyId);                dependencyGraph.addVertex(ontologyId);                if (od.getFirst() != null) {                    for (var imported : od.getFirst().getNamespace().getImported()) {                        dependencyGraph.addVertex(imported);                        dependencyGraph.addEdge(imported, ontologyId);                    }                } else {                    for (var imported : od.getSecond().getImportedOntologies()) {                        dependencyGraph.addVertex(imported);                        dependencyGraph.addEdge(imported, ontologyId);                    }                }            }            CycleDetector<String, DefaultEdge> cycleDetector = new CycleDetector<>(dependencyGraph);            if (cycleDetector.detectCycles()) {                scope.error("Circular dependencies in ontology graph: cannot continue",                        Klab.ErrorCode.CIRCULAR_REFERENCES, Klab.ErrorContext.ONTOLOGY);                return Collections.emptyList();            }            // finish building the ontologies in the given order using a new language validator            TopologicalOrderIterator<String, DefaultEdge> sort =                    new TopologicalOrderIterator<>(dependencyGraph);            while (sort.hasNext()) {                var ontologyId = sort.next();                var od = cache.get(ontologyId);                if (od == null) {                    scope.error("Ontology " + ontologyId + " cannot be resolved either locally or through" + " the network", Klab.ErrorCode.UNRESOLVED_REFERENCE, Klab.ErrorContext.ONTOLOGY);                    return Collections.emptyList();                }                AtomicBoolean errors = new AtomicBoolean(false);                List<Notification> notifications = new ArrayList<>();                var ontology = od.getSecond();                if (ontology == null) {                    var syntax = new OntologySyntaxImpl(od.getFirst(), languageValidationScope) {                        @Override                        protected void logWarning(ParsedObject target, EObject object,                                                  EStructuralFeature feature, String message) {                            notifications.add(makeNotification(target, object, feature, message,                                    org.integratedmodelling.klab.api.services.runtime.Notification.Level.Warning));                        }                        @Override                        protected void logError(ParsedObject target, EObject object,                                                EStructuralFeature feature, String message) {                            notifications.add(makeNotification(target, object, feature, message,                                    org.integratedmodelling.klab.api.services.runtime.Notification.Level.Error));                            errors.set(true);                        }                    };                    ontology = LanguageAdapter.INSTANCE.adaptOntology(syntax,                            ontologyProjects.get(syntax.getName()), notifications);                    documentURLs.put(ontology.getUrn(), urlCache.get(ontology.getUrn()));                }                if (errors.get()) {                    scope.error("Logical errors in ontology " + ontologyId + ": cannot continue",                            Klab.ErrorCode.RESOURCE_VALIDATION, Klab.ErrorContext.ONTOLOGY);                    //                    return Collections.emptyList();                }                languageValidationScope.addNamespace(ontology);                this._ontologyOrder.add(ontology);                this._ontologyMap.put(ontology.getUrn(), ontology);                if (od.getThird()) {                    this._worldviewOntologies.add(ontology);                }            }        }        return worldviewOnly ? _worldviewOntologies : _ontologyOrder;    }    /**     * Return all the namespaces in order of dependency. Resolution is internal like in     * {@link #getOntologies(boolean)}.     *     * @return     */    public List<KimNamespace> getNamespaces() {        if (_namespaceOrder == null) {            _namespaceOrder = new ArrayList<>();            _namespaceMap = new HashMap<>();            // TODO load them from all projects in dependency order, same as ontologies; fill in the URL            //  cache and everything        }        return _namespaceOrder;    }    public ResourcesConfiguration getConfiguration() {        return this.configuration;    }    public List<KActorsBehavior> getBehaviors() {        if (_behaviorOrder == null) {            _behaviorOrder = new ArrayList<>();            _behaviorMap = new HashMap<>();            // TODO load them from all projects in dependency order, same as ontologies; fill in the URL            //  cache and everything        }        return _behaviorOrder;    }    public List<KimObservationStrategyDocument> getStrategyDocuments() {        if (_observationStrategyDocuments == null) {            _observationStrategyDocuments = new ArrayList<>();            _observationStrategyDocumentMap = new HashMap<>();            // TODO load them from all projects in dependency order, same as ontologies; fill in the URL            //  cache and everything        }        return _observationStrategyDocuments;    }    public List<String> getWorkspaceURNs() {        return new ArrayList<>(workspaces.keySet());    }    /**     * Create the project implementation with every namespace and manifest filled in. CAUTION this can be a     * large object. The project must exist in a local workspace; if not, null will be returned without     * error.     *     * @param projectId     * @return the filled in project or null     */    public Project createProjectData(String projectId) {        ProjectImpl ret = null;        var pdesc = projectDescriptors.get(projectId);        if (pdesc != null && pdesc.storage != null) {            ret = new ProjectImpl();            ret.setUrn(projectId);            // TODO improve metadata with service IDs, load time, stats, any info etc.            // TODO should only add a file:/ URL if the project is local to the requester (check scope)            ret.getMetadata().put(Metadata.RESOURCES_STORAGE_URL, pdesc.storage.getUrl());            ret.setManifest(pdesc.manifest);            for (KimOntology ontology : getOntologies(false)) {                if (projectId.equals(ontology.getProjectName())) {                    ret.getOntologies().add(ontology);                }            }            for (KimNamespace namespace : getNamespaces()) {                if (projectId.equals(namespace.getProjectName())) {                    ret.getNamespaces().add(namespace);                }            }            // TODO the rest        }        this.projects.put(ret.getUrn(), ret);        return ret;    }    List<ObservationStrategySyntax> getStrategies() {        return null;    }    /**     * Import a project from a URL into the given workspace and return the associated storage. Project     * configuration must not exist already, if so it is removed and rebuilt. All project implications in the     * workspace are resolved downstream.     *     * @param projectUrl     * @param workspaceName     * @return     */    public ProjectStorage importProject(String projectUrl, String workspaceName) {        String projectName = Utils.URLs.getURLBaseName(projectUrl);        var configuration = this.configuration.getProjectConfiguration().get(projectName);        if (configuration != null) {            scope.warn("Configuration of imported project " + projectName + " exists already: " +                    "import will " +                    "rewrite it");        }        ProjectStorage ret = null;        try {            if (Utils.Git.isRemoteGitURL(projectUrl)) {                File workspace = BaseService.getConfigurationSubdirectory(startupOptions, "workspaces");                File projectHome = new File(workspace + File.separator + projectName);                if (projectHome.isDirectory()) {                    scope.warn("Deleting and reimporting " + projectName + " from Git repository " + projectUrl);                }                try {                    projectName = Utils.Git.clone(projectUrl, workspace, true, scope);                    if (projectHome.exists()) {                        ret = new FileProjectStorage(projectHome, this::handleFileChange);                    }                } catch (Throwable t) {                    // just make the return value null                    if (projectHome.exists()) {                        Utils.Files.deleteQuietly(projectHome);                    }                }            } else if (projectUrl.startsWith("http")) {                /*                 * TODO                 *                 * Load from another service. These projects may be served as mirrors or just                 * kept to meet dependencies, according to the 'served' bit in the                 * configuration. The source of truth should remain the source code, hosted in a                 * single place (the remote service); mechanisms should be in place to store the                 * original server and check for changes and new versions.                 */            } else if (projectUrl.startsWith("file:") || new File(projectUrl).isFile()) {                var file = Utils.URLs.getFileForURL(projectUrl);                if (file.isDirectory()) {                    ret = new FileProjectStorage(file, this::handleFileChange);                } else if (Utils.Files.JAVA_ARCHIVE_EXTENSIONS.contains(Utils.Files.getFileExtension(file))) {                    // TODO ret = read from archive                }            }        } catch (Throwable t) {            scope.error(t);        } finally {            //            service.setBusy(false);        }        /**         * (Re)Create configuration         */        if (ret != null) {            configuration = new ResourcesConfiguration.ProjectConfiguration();            configuration.setSourceUrl(projectUrl);            configuration.setWorkspaceName(workspaceName);            configuration.setSyncIntervalMinutes(DEFAULT_GIT_SYNC_INTERVAL_MINUTES);            configuration.setStorageType(ret.getType());            /*             * Default privileges are exclusive to the service, the API can be used to change them             */            configuration.setPrivileges(ResourcePrivileges.empty());            if (ret instanceof FileProjectStorage fps) {                configuration.setLocalPath(fps.getRootFolder());            }            this.configuration.getProjectConfiguration().put(ret.getProjectName(), configuration);            configuration.setWorldview(readManifest(ret).getDefinedWorldview() != null);            Set<String> projects = this.configuration.getWorkspaces().get(workspaceName);            if (projects == null) {                projects = new LinkedHashSet<>();                this.configuration.getWorkspaces().put(workspaceName, projects);            }            projects.add(ret.getProjectName());            if (!this.workspaces.containsKey(workspaceName)) {                var ws = new WorkspaceImpl();                ws.setUrn(workspaceName);                this.workspaces.put(workspaceName, ws);            }            saveConfiguration();        }        return ret;    }    public Project loadProject(ProjectStorage storage, String workspaceName) {        var configuration = this.configuration.getProjectConfiguration().get(storage.getProjectName());        if (configuration == null) {            throw new KlabResourceAccessException("project configuration for " + storage.getProjectName() + " is missing");        }        // clear all caches        this._projectLoadOrder = null;        this._ontologyOrder = null;        this._ontologyMap = null;        this._namespaceMap = null;        this._namespaceOrder = null;        this._worldview = null;        ProjectDescriptor descriptor = new ProjectDescriptor();        descriptor.storage = storage;        descriptor.manifest = readManifest(storage);        descriptor.workspace = workspaceName;        descriptor.name = storage.getProjectName();        descriptor.updateInterval = configuration.getSyncIntervalMinutes();        projectDescriptors.put(storage.getProjectName(), descriptor);        if (!this.worldviewProvider && descriptor.manifest.getDefinedWorldview() != null) {            this.worldviewProvider = true;            this.adoptedWorldview = descriptor.manifest.getDefinedWorldview();        }        return createProjectData(storage.getProjectName());    }    /**     * Either called automatically by the file watcher in {@link FileProjectStorage} or explicitly invoked in     * synchronous CRUD operations on projects when the project is locked by the requesting user.     * <p>     * TODO make the final parameter an array of URLs to handle multiple concurrent changes     *     * @param project     * @param changes     */    public List<ResourceSet> handleFileChange(String project,                                              List<Triple<ProjectStorage.ResourceType, CRUDOperation, URL>> changes) {        if (loading.get()) {            return Collections.emptyList();        }        /*        populate the resource set changes in order of workspace affected         */        Map<String, ResourceSet> result = new LinkedHashMap<>();        // this may or may not end up in the result set        var worldviewChange = new ResourceSet();        worldviewChange.setWorkspace(Worldview.WORLDVIEW_WORKSPACE_IDENTIFIER);        var projectDescriptor = projectDescriptors.get(project);        Set<String> affectedOntologies = new HashSet<>();        Set<String> affectedNamespaces = new HashSet<>();        Set<String> affectedBehaviors = new HashSet<>();        Set<String> affectedStrategies = new HashSet<>();        List<KlabDocument<?>> newAssets = new ArrayList<>();        boolean mustRecomputeOrder = false;        for (var change : changes) {            if (change.getSecond() == CRUDOperation.DELETE) {                // there's no new asset but all the affected must be reloaded                if (projectDescriptor.storage instanceof FileProjectStorage fps) {                    String deletedUrn = fps.getDocumentUrn(change.getFirst(), change.getThird());                    if (deletedUrn != null) {                        affectedOntologies.add(deletedUrn);                        for (var ontology : getOntologies(false)) {                            if (!Sets.intersection(affectedOntologies, ontology.importedNamespaces(false)).isEmpty()) {                                affectedOntologies.add(ontology.getUrn());                            }                        }                        affectedNamespaces.addAll(affectedOntologies);                        for (var namespace : getNamespaces()) {                            if (!Sets.intersection(affectedNamespaces, namespace.importedNamespaces(false)).isEmpty()) {                                affectedNamespaces.add(namespace.getUrn());                            }                        }                        affectedNamespaces.removeAll(affectedOntologies);                        // same for strategies and behaviors                        affectedBehaviors.addAll(affectedOntologies);                        for (var behavior : getBehaviors()) {                            if (!Sets.intersection(affectedBehaviors, behavior.importedNamespaces(false)).isEmpty()) {                                affectedBehaviors.add(behavior.getUrn());                            }                        }                        affectedBehaviors.removeAll(affectedOntologies);                        affectedStrategies.addAll(affectedOntologies);                        for (var strategies : getStrategyDocuments()) {                            if (!Sets.intersection(affectedStrategies,                                    strategies.importedNamespaces(false)).isEmpty()) {                                affectedStrategies.add(strategies.getUrn());                            }                        }                        affectedStrategies.removeAll(affectedOntologies);                    }                }            } else if (change.getSecond() == CRUDOperation.CREATE) {                // just a new asset, nothing should be affected, let this through                KlabDocument<?> newAsset = switch (change.getFirst()) {                    case ONTOLOGY -> loadOntology(change.getThird(), project);                    case MODEL_NAMESPACE -> loadNamespace(change.getThird(), project);                    case BEHAVIOR -> loadBehavior(change.getThird(), project);                    case STRATEGY -> loadStrategy(change.getThird(), project);                    default -> null;                };                // TODO Add document to project. FileStorage should have added it to the repository if                //  there's one                newAssets.add(newAsset);            } else {                /*                figure out which asset is affected and load it                */                KlabDocument<?> newAsset = switch (change.getFirst()) {                    case ONTOLOGY -> loadOntology(change.getThird(), project);                    case MODEL_NAMESPACE -> loadNamespace(change.getThird(), project);                    case BEHAVIOR -> loadBehavior(change.getThird(), project);                    case STRATEGY -> loadStrategy(change.getThird(), project);                    default -> null;                };                if (newAsset != null) {                    newAssets.add(newAsset);                    KlabDocument<?> oldAsset = switch (newAsset) {                        case KimOntology ontology -> getOntology(ontology.getUrn());                        case KimNamespace namespace -> getNamespace(namespace.getUrn());                        case KActorsBehavior behavior -> getBehavior(behavior.getUrn());                        case KimObservationStrategyDocument strategy ->                                getStrategyDocument(strategy.getUrn());                        default -> null;                    };                    if (oldAsset == null) {                        scope.error("Internal: cannot update a non-existing document: " + change.getSecond());                        return Collections.emptyList();                    }                    /*                    if the implicit or explicit import statements have changed, the full order of loading                    must be                    recomputed.                    */                    if (!mustRecomputeOrder) {                        mustRecomputeOrder =                                !newAsset.importedNamespaces(false).equals(oldAsset.importedNamespaces(false));                    }                    /*                    establish what needs to be reloaded and which workspaces are affected: dry run across                    ontologies (if the asset is an ontology), then strategies, namespaces and behaviors. First                    establish the affected ones and compile the result sets per workspace. Then send those and                    start the loading based on the collected metadata in the sets.                    */                    affectedOntologies.add(oldAsset.getUrn());                    for (var ontology : getOntologies(false)) {                        if (!Sets.intersection(affectedOntologies, ontology.importedNamespaces(false)).isEmpty()) {                            affectedOntologies.add(ontology.getUrn());                        }                    }                    affectedNamespaces.addAll(affectedOntologies);                    for (var namespace : getNamespaces()) {                        if (!Sets.intersection(affectedNamespaces, namespace.importedNamespaces(false)).isEmpty()) {                            affectedNamespaces.add(namespace.getUrn());                        }                    }                    affectedNamespaces.removeAll(affectedOntologies);                    // same for strategies and behaviors                    affectedBehaviors.addAll(affectedOntologies);                    for (var behavior : getBehaviors()) {                        if (!Sets.intersection(affectedBehaviors, behavior.importedNamespaces(false)).isEmpty()) {                            affectedBehaviors.add(behavior.getUrn());                        }                    }                    affectedBehaviors.removeAll(affectedOntologies);                    affectedStrategies.addAll(affectedOntologies);                    for (var strategies : getStrategyDocuments()) {                        if (!Sets.intersection(affectedStrategies, strategies.importedNamespaces(false)).isEmpty()) {                            affectedStrategies.add(strategies.getUrn());                        }                    }                    affectedStrategies.removeAll(affectedOntologies);                } else {                    // TODO report failure                }            }            this.loading.set(true);                /*                make the actual change. For each modification: if                it's the modified object, reset the corresponding concept descriptors in the language                validator (if an ontology) or the kbox for the namespace. Then reload and substitute in the                ontology, worldview and namespace arrays for the modified and the affected in the order                specified by the resourcesets.                 */                /*                 If dependency statements have changed in the modified file, a NEW order of everything is                 computed. The result set contains all the affected files IN THE NEW ORDER. The order                 can stay the same if the dependency statements haven't changed between the old and the new                 version.                 */            if (mustRecomputeOrder) {                computeLoadOrder();            }            for (var newAsset : newAssets) {                /*                compile the ResourceSets based on the (possibly new) order                 */                for (var ontology : getOntologies(false)) {                    if (affectedOntologies.contains(ontology.getUrn())) {                        var descriptor = addToResultSet(ontology, Workspace.EXTERNAL_WORKSPACE_URN, result);                        if (_worldviewOntologies.stream().anyMatch(ont -> newAsset.getUrn().equals(ont.getUrn()))) {                            worldviewChange.getOntologies().add(descriptor);                            worldviewChange.getResources().add(descriptor);                        }                    }                }                for (var namespace : getNamespaces()) {                    if (affectedNamespaces.contains(namespace.getUrn())) {                        addToResultSet(namespace, Workspace.EXTERNAL_WORKSPACE_URN, result);                    }                }                for (var behavior : getBehaviors()) {                    if (affectedBehaviors.contains(behavior.getUrn())) {                        addToResultSet(behavior, Workspace.EXTERNAL_WORKSPACE_URN, result);                    }                }                for (var strategies : getStrategyDocuments()) {                    if (affectedStrategies.contains(strategies.getUrn())) {                        addToResultSet(strategies, Workspace.EXTERNAL_WORKSPACE_URN, result);                    }                }                /*                TODO reload all the affected namespaces from their source, including the language validator                  and kbox, using the                 possibly new order. External namespaces that depend on anything that has changed should                 probably cause a warning.                 */                List<KlabDocument<?>> newDocuments = new ArrayList<>();                for (KimOntology oldOntology : _ontologyOrder) {                    if (affectedOntologies.contains(oldOntology.getUrn())) {                        boolean isWorldview =                                _worldviewOntologies.stream().anyMatch(o -> newAsset.getUrn().equals(o.getUrn()));                        this.languageValidationScope.clearNamespace(newAsset.getUrn());                        var newOntology = oldOntology.getUrn().equals(newAsset.getUrn()) ? newAsset :                                          loadOntology(documentURLs.get(oldOntology.getUrn()),                                                  oldOntology.getProjectName());                        this.languageValidationScope.addNamespace((KimOntology) newAsset);                        newDocuments.add(newOntology);                    }                }                for (var oldNamespace : _namespaceOrder) {                    if (affectedNamespaces.contains(oldNamespace.getUrn())) {                        newDocuments.add(oldNamespace.getUrn().equals(newAsset.getUrn()) ? newAsset :                                         loadNamespace(documentURLs.get(oldNamespace.getUrn()),                                                 oldNamespace.getProjectName()));                    }                }                for (var oldBehavior : _behaviorOrder) {                    if (affectedBehaviors.contains(oldBehavior.getUrn())) {                        newDocuments.add(oldBehavior.getUrn().equals(newAsset.getUrn()) ? newAsset :                                         loadBehavior(documentURLs.get(oldBehavior.getUrn()),                                                 oldBehavior.getProjectName()));                    }                }                for (var oldStrategy : _observationStrategyDocuments) {                    if (affectedStrategies.contains(oldStrategy.getUrn())) {                        newDocuments.add(oldStrategy.getUrn().equals(newAsset.getUrn()) ? newAsset :                                         loadStrategy(documentURLs.get(oldStrategy.getUrn()),                                                 oldStrategy.getProjectName()));                    }                }                for (var document : newDocuments) {                    switch (document) {                        case KimOntology ontology -> {                            if (_worldviewOntologies.stream().anyMatch(o -> newAsset.getUrn().equals(o.getUrn()))) {                                _worldviewOntologies =                                        _worldviewOntologies.stream().map(o -> o.getUrn().equals(document.getUrn()) ? ontology : o).collect(toList());                                _worldview.setOntologies(_worldviewOntologies);                            }                            _ontologyOrder =                                    _ontologyOrder.stream().map(o -> o.getUrn().equals(document.getUrn()) ?                                                                     ontology : o).collect(toList());                            _ontologyMap.put(ontology.getUrn(), ontology);                        }                        case KimNamespace namespace -> {                            _namespaceOrder =                                    _namespaceOrder.stream().map(o -> o.getUrn().equals(document.getUrn())                                                                      ? namespace : o).collect(toList());                            _namespaceMap.put(namespace.getUrn(), namespace);                        }                        case KActorsBehavior behavior -> {                            _behaviorOrder =                                    _behaviorOrder.stream().map(o -> o.getUrn().equals(document.getUrn()) ?                                                                     behavior : o).collect(toList());                            _behaviorMap.put(behavior.getUrn(), behavior);                        }                        case KimObservationStrategyDocument strategies -> {                            _observationStrategyDocuments =                                    _observationStrategyDocuments.stream().map(o -> o.getUrn().equals(document.getUrn()) ? strategies : o).collect(toList());                            _observationStrategyDocumentMap.put(strategies.getUrn(), strategies);                            _worldview.setObservationStrategies(_observationStrategyDocuments);                        }                        default -> throw new KlabIllegalStateException("can't deal with " + document);                    }                }            }            this.loading.set(false);        }        var ret = new ArrayList<ResourceSet>();        if (!worldviewChange.getResources().isEmpty()) {            ret.add(worldviewChange);        }        ret.addAll(result.values());        /**         Report a ResourceSet per workspace affected. The listening end(s) will have to request the         contents.         */        for (var resourceSet : ret) {            scope.send(Message.MessageClass.ResourceLifecycle, Message.ForwardingPolicy.Forward,                    Message.MessageType.WorkspaceChanged, resourceSet);        }        return ret;        //        //        return Collections.emptyList();    }    /**     * Add the document info to the result set that corresponds to the passed workspace in the passed result     * map, creating whatever is needed. If the external workspace name is given, use that for an external     * document, otherwise skip it.     *     * @param asset     * @param result     */    private ResourceSet.Resource addToResultSet(KlabDocument<?> asset, String externalWorkspaceId, Map<String,            ResourceSet> result) {        String workspace = getWorkspaceForProject(asset.getProjectName());        ResourceSet.Resource resource = null;        if (workspace == null) workspace = externalWorkspaceId;        if (workspace != null) {            ResourceSet resourceSet = result.get(workspace);            if (resourceSet == null) {                resourceSet = new ResourceSet();                resourceSet.setWorkspace(workspace);                result.put(workspace, resourceSet);            }            resource = new ResourceSet.Resource();            resource.setResourceUrn(asset.getUrn());            resource.setResourceVersion(asset.getVersion());            resource.setServiceId(configuration.getServiceId());            resource.setKnowledgeClass(KlabAsset.classify(asset));            resource.getNotifications().addAll(asset.getNotifications());            if (resourceSet.getServices().containsKey(configuration.getServiceId())) {                resourceSet.getServices().put(configuration.getServiceId(), service.getUrl());            }            switch (resource.getKnowledgeClass()) {                case RESOURCE -> {                    // TODO                }                case NAMESPACE -> {                    resourceSet.getNamespaces().add(resource);                }                case BEHAVIOR, SCRIPT, TESTCASE, APPLICATION -> {                    resourceSet.getBehaviors().add(resource);                }                case ONTOLOGY -> {                    resourceSet.getOntologies().add(resource);                }                case OBSERVATION_STRATEGY_DOCUMENT -> {                    resourceSet.getObservationStrategies().add(resource);                }            }            resourceSet.getResources().add(resource);        }        return resource;    }    /**     * Recompute from scratch the order of all known ontologies, namespaces, behaviors, strategies and     * projects     */    private void computeLoadOrder() {        sortDocuments(_ontologyOrder, Klab.ErrorContext.ONTOLOGY);        sortDocuments(_namespaceOrder, Klab.ErrorContext.NAMESPACE);        sortDocuments(_behaviorOrder, Klab.ErrorContext.BEHAVIOR);    }    private <T extends KlabDocument<?>> void sortDocuments(List<T> documents,                                                           Klab.ErrorContext errorContext) {        Graph<String, DefaultEdge> dependencyGraph = new DefaultDirectedGraph<>(DefaultEdge.class);        Map<String, T> documentMap = new HashMap<>();        for (var document : documents) {            documentMap.put(document.getUrn(), document);            dependencyGraph.addVertex(document.getUrn());            for (var imported : document.importedNamespaces(true)) {                dependencyGraph.addVertex(imported);                dependencyGraph.addEdge(imported, document.getUrn());            }        }        CycleDetector<String, DefaultEdge> cycleDetector = new CycleDetector<>(dependencyGraph);        if (cycleDetector.detectCycles()) {            scope.error("Circular dependencies in workspace: cannot continue. Cyclic dependencies affect " + cycleDetector.findCycles(), Klab.ErrorCode.CIRCULAR_REFERENCES, errorContext);            return;        }        // finish building the ontologies in the given order using a new language validator        documents.clear();        TopologicalOrderIterator<String, DefaultEdge> sort = new TopologicalOrderIterator<>(dependencyGraph);        while (sort.hasNext()) {            documents.add(documentMap.get(sort.next()));        }    }    /**     * Return the nzme of the local workspace that hosts the passed project, or null.     *     * @param projectName     * @return     */    public String getWorkspaceForProject(String projectName) {        var pd = projectDescriptors.get(projectName);        return pd == null ? null : pd.workspace;    }    public KimOntology getOntology(String urn) {        return updateStatus(_ontologyMap.get(urn));    }    public KimNamespace getNamespace(String urn) {        return updateStatus(_namespaceMap.get(urn));    }    public KActorsBehavior getBehavior(String urn) {        return null; // TODO _ontologyMap.get(urn);    }    public KimObservationStrategyDocument getStrategyDocument(String urn) {        return null; // _ontologyMap.get(urn);    }    private KimOntology loadOntology(URL url, String project) {        try (var input = url.openStream()) {            List<Notification> notifications = new ArrayList<>();            var parsed = ontologyParser.parse(input, notifications);            var syntax = new OntologySyntaxImpl(parsed, languageValidationScope) {                @Override                protected void logWarning(ParsedObject target, EObject object, EStructuralFeature feature,                                          String message) {                    notifications.add(makeNotification(target, object, feature, message,                            org.integratedmodelling.klab.api.services.runtime.Notification.Level.Warning));                }                @Override                protected void logError(ParsedObject target, EObject object, EStructuralFeature feature,                                        String message) {                    notifications.add(makeNotification(target, object, feature, message,                            org.integratedmodelling.klab.api.services.runtime.Notification.Level.Error));                }            };            return LanguageAdapter.INSTANCE.adaptOntology(syntax, project, notifications);        } catch (IOException e) {            scope.error(e);            return null;        }    }    private KimNamespace loadNamespace(URL url, String project) {        //        try (var input = url.openStream()) {        //            List<Notification> notifications = new ArrayList<>();        //            var parsed = namespaceParser.parse(input, notifications);        //            var syntax = new NamespaceSyntaxImpl(parsed, languageValidationScope) {        //        //                @Override        //                protected void logWarning(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                          String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Warning));        //                }        //        //                @Override        //                protected void logError(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                        String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Error));        //                }        //            };        //            return LanguageAdapter.INSTANCE.adaptNamespace(syntax, project, notifications);        //        } catch (IOException e) {        //            scope.error(e);        return null;        //        }    }    private KActorsBehavior loadBehavior(URL url, String project) {        //        try (var input = url.openStream()) {        //            List<Notification> notifications = new ArrayList<>();        //            var parsed = behaviorParser.parse(input, notifications);        //            var syntax = new KActorsBehaviorImpl(parsed, languageValidationScope) {        //        //                @Override        //                protected void logWarning(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                          String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Warning));        //                }        //        //                @Override        //                protected void logError(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                        String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Error));        //                }        //            };        //            return LanguageAdapter.INSTANCE.adaptBehavior(syntax, project, notifications);        //        } catch (IOException e) {        //            scope.error(e);        return null;        //        }    }    private KimObservationStrategyDocument loadStrategy(URL url, String project) {        //        try (var input = url.openStream()) {        //            List<Notification> notifications = new ArrayList<>();        //            var parsed = behaviorParser.parse(input, notifications);        //            var syntax = new KActorsBehaviorImpl(parsed, languageValidationScope) {        //        //                @Override        //                protected void logWarning(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                          String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Warning));        //                }        //        //                @Override        //                protected void logError(ParsedObject target, EObject object, EStructuralFeature        //                feature,        //                                        String message) {        //                    notifications.add(makeNotification(target, object, feature, message,        //                            org.integratedmodelling.klab.api.services.runtime.Notification.Level        //                            .Error));        //                }        //            };        //            return LanguageAdapter.INSTANCE.adaptBehavior(syntax, project, notifications);        //        } catch (IOException e) {        //            scope.error(e);        return null;        //        }    }    private Notification makeNotification(ParsedObject target, EObject object, EStructuralFeature feature,                                          String message, Notification.Level level) {        var ret = new NotificationImpl();        return ret;    }    public List<Pair<ProjectStorage, Project>> getProjectLoadOrder() {        return this._projectLoadOrder;    }    /**     * Read, validate, resolve and sorts projects locally (all workspaces) and from the network, returning the     * load order for all projects, including local and externally resolved ones. Check errors (reported in     * the configured monitor) and unresolved projects after calling. Does not throw exceptions.     * <p>     * While loading the workspaces, (re)build the workspace list so that {@link #getWorkspaces()} can work.     * The workspaces are also listed in order of first-contact dependency although circular deps between     * workspaces are permitted.     *     * @return the load order or an empty collection in case of circular dependencies or no configuration. If     * errors happened they will be notified through the monitor and {@link #getUnresolvedProjects()} will     * return the list of projects that have not resolved properly (including resource not found and version     * mismatch errors). Only one of the elements in each returned pair will be non-null.     */    public synchronized boolean loadWorkspace() {        /*        TODO wait until this.loading.get() is false! Could be straight in here or we could just use this         from an operation queue. API admin ops and retrievals should also ensure that they only return         when not loading.         Use this pattern        if(lock.compareAndSet(false, true)){        try {            //do           } catch(Exception e){            //error handling           } finally {             lock.set(false);          }        }         */        this.loading.set(true);        this._projectLoadOrder = new ArrayList<>();        this.workspaces.clear();        this.projects.clear();        // build a version-aware dependency tree        Graph<Pair<String, Version>, DefaultEdge> dependencyGraph =                new DefaultDirectedGraph<>(DefaultEdge.class);        for (String s : projectDescriptors.keySet()) {            var snode = Pair.of(s, projectDescriptors.get(s).manifest.getVersion());            dependencyGraph.addVertex(snode);            for (var dep : projectDescriptors.get(s).manifest.getPrerequisiteProjects()) {                var pnode = Pair.of(dep.getFirst(), dep.getSecond());                dependencyGraph.addVertex(pnode);                dependencyGraph.addEdge(pnode, snode);            }        }        CycleDetector<Pair<String, Version>, DefaultEdge> cycleDetector =                new CycleDetector<>(dependencyGraph);        if (cycleDetector.detectCycles()) {            scope.error(Klab.ErrorCode.CIRCULAR_REFERENCES, Klab.ErrorContext.PROJECT, "Projects in " +                    "configuration have cyclic dependencies on each other: " + "will not " + "proceed. " +                    "Review configuration");            this.loading.set(false);            return false;        } else {            // establish load order: a list of either ProjectStorage or external Project            TopologicalOrderIterator<Pair<String, Version>, DefaultEdge> sort =                    new TopologicalOrderIterator(dependencyGraph);            while (sort.hasNext()) {                var proj = sort.next();                // verify availability                if (projectDescriptors.get(proj.getFirst()) != null) {                    // local dependency: check version                    var pd = projectDescriptors.get(proj.getFirst());                    if (pd.manifest.getVersion().compatible(proj.getSecond())) {                        this._projectLoadOrder.add(Pair.of(pd.storage, null));                    } else {                        scope.error(Klab.ErrorContext.PROJECT, Klab.ErrorCode.MISMATCHED_VERSION, "Project "                                + proj.getFirst() + "@" + proj.getSecond() + " is required" + " by other " + "projects in workspace but incompatible version " + pd.manifest.getVersion() + " is available in local workspace");                        unresolvedProjects.add(proj);                    }                } else {                    var externalProject = externalProjectResolver.apply(proj.getFirst());                    if (externalProject != null) {                        // check version                        if (externalProject.getManifest().getVersion().compatible(proj.getSecond())) {                            ProjectDescriptor descriptor = new ProjectDescriptor();                            descriptor.externalProject = externalProject;                            descriptor.manifest = externalProject.getManifest();                            descriptor.workspace = null;                            descriptor.name = proj.getFirst();                            projectDescriptors.put(proj.getFirst(), descriptor);                            this._projectLoadOrder.add(Pair.of(null, externalProject));                        } else {                            scope.error(Klab.ErrorContext.PROJECT, Klab.ErrorCode.MISMATCHED_VERSION,                                    "Project " + proj.getFirst() + "@" + proj.getSecond() + " is " +                                            "required by other projects in workspace but incompatible " +                                            "version " + externalProject.getManifest().getVersion() + " is "                                            + "available " + "externally");                            unresolvedProjects.add(proj);                        }                    } else {                        scope.error(Klab.ErrorContext.PROJECT, Klab.ErrorCode.UNRESOLVED_REFERENCE,                                "Project " + proj.getFirst() + "@" + proj.getSecond() + " is required" + " "                                        + "by other projects in workspace but cannot be resolved from the " + "network");                        unresolvedProjects.add(proj);                    }                }            }        }        /*        we have workspaces and project descriptors; load ontologies and namespaces         */        getOntologies(false);        getNamespaces();        // build workspace and project descriptors and attribute all namespaces        for (var proj : this._projectLoadOrder) {            if (proj.getFirst() != null) {                var pdesc = projectDescriptors.get(proj.getFirst().getProjectName());                if (pdesc != null && pdesc.storage != null) {                    WorkspaceImpl ws = null;                    if (pdesc.workspace != null) {                        ws = this.workspaces.get(pdesc.workspace);                        if (ws == null) {                            ws = new WorkspaceImpl();                            ws.setUrn(pdesc.workspace);                            this.workspaces.put(pdesc.workspace, ws);                        }                    }                    var project = createProjectData(pdesc.name);                    this.projects.put(pdesc.name, project);                    if (ws != null) {                        ws.getProjects().add(project);                    }                }            }        }        this.loading.set(false);        return true;    }    private ProjectStorage newProject(String projectName, String workspaceName) {        return null;    }    public SemanticSyntax resolveConcept(String conceptDefinition) {        return this.observableParser.parseConcept(conceptDefinition);    }    public ObservableSyntax resolveObservable(String observableDefinition) {        return this.observableParser.parseObservable(observableDefinition);    }    public boolean removeProject(String projectName) {        ResourcesConfiguration.ProjectConfiguration configuration =                this.configuration.getProjectConfiguration().get(projectName);        var project = this.projectDescriptors.get(projectName);        if (project != null && project.storage != null) {            Workspace workspace = getWorkspace(project.workspace);            Utils.Files.deleteQuietly(configuration.getLocalPath());            if (this.configuration.getWorkspaces().get(project.workspace) != null) {                this.configuration.getWorkspaces().get(project.workspace).remove(projectName);            }            //        // remove namespaces, behaviors and resources            //        for (KimNamespace namespace : project.getNamespaces()) {            //            this.localNamespaces.remove(namespace.getUrn());            //        }            //        for (KActorsBehavior behavior : project.getBehaviors()) {            //            this.localBehaviors.remove(behavior.getUrn());            //        }            //        for (String resource : project.getResourceUrns()) {            //            localResources.remove(resource);            //            catalog.remove(resource);            //        }            //        this.localProjects.remove(projectName);            workspace.getProjects().remove(project);            saveConfiguration();        }        //        db.commit();        return true;    }    private Project.Manifest readManifest(ProjectStorage project) {        return Utils.Json.load(project.listResources(ProjectStorage.ResourceType.MANIFEST).getFirst(),                ProjectImpl.ManifestImpl.class);    }    public WorkspaceImpl getWorkspace(String workspaceName) {        return updateStatus(this.workspaces.get(workspaceName));    }    public Collection<Workspace> getWorkspaces() {        List<Workspace> ret = new ArrayList<>();        for (var wsId : configuration.getWorkspaces().keySet()) {            var workspace = getWorkspace(wsId);            ret.add(workspace);        }        return ret;    }    public List<Pair<String, Version>> getUnresolvedProjects() {        return unresolvedProjects;    }    private abstract static class Parser<T extends EObject> {        @Inject        protected IParser parser;        public Parser() {            createInjector().injectMembers(this);        }        protected abstract Injector createInjector();        public T parse(InputStream input, List<Notification> errors) {            return parse(new InputStreamReader(input, StandardCharsets.UTF_8), errors);        }        /**         * Parses data provided by an input reader using Xtext and returns the root node of the resulting         * object tree.         *         * @param reader Input reader         * @return root object node         * @throws IOException when errors occur during the parsing process         */        public T parse(Reader reader, List<Notification> errors) {            try {                IParseResult result = parser.parse(reader);                for (var error : result.getSyntaxErrors()) {                    System.out.println(error);                }                return (T) result.getRootASTElement();            } catch (Throwable throwable) {                errors.add(Notification.create(throwable));            }            return null;        }    }    public Worldview getWorldview() {        if (_worldview == null) {            _worldview = new WorldviewImpl();            _worldview.getOntologies().addAll(getOntologies(true));            // basic validations: non-empty, first must be root, take the worldview name from it            // go back to the projects and load all observation strategies, adding project metadata            for (var pd : projectDescriptors.values()) {                if (pd.manifest.getDefinedWorldview() == null) {                    continue;                }                if (pd.externalProject != null) {                    for (var strategy : pd.externalProject.getObservationStrategies()) {                        _worldview.getObservationStrategies().add(strategy);                    }                } else {                    for (var strategyUrl : pd.storage.listResources(ProjectStorage.ResourceType.STRATEGY)) {                        var parsed = strategyParser.parseStrategies(strategyUrl, pd.name);                        if (parsed == null) {                            _worldview.setEmpty(true);                            return _worldview;                        }                        _worldview.getObservationStrategies().add(LanguageAdapter.INSTANCE.adaptStrategies(parsed));                    }                }            }        }            /*            Validate the first ontology as the root ontology and set the worldview name from it             */        if (!_worldview.getOntologies().isEmpty()) {            for (var ontology : _worldview.getOntologies()) {                if (Utils.Notifications.hasErrors(ontology.getNotifications())) {                    _worldview.setEmpty(true);                    scope.error("Namespace " + ontology.getUrn() + " has fatal errors: worldview " + "is " +                            "inconsistent");                }            }            KimOntology root = _worldview.getOntologies().get(0);            if (!(root.getDomain() == KimOntology.rootDomain)) {                _worldview.setEmpty(true);                scope.error("The first namespace in the worldview is not the root namespace: worldview " +                        "is inconsistent");            } else {                _worldview.setUrn(root.getUrn());            }        } else {            _worldview.setEmpty(true);        }        return _worldview;    }    private void saveConfiguration() {        File config = BaseService.getFileInConfigurationDirectory(startupOptions, "resources.yaml");        org.integratedmodelling.common.utils.Utils.YAML.save(this.configuration, config);    }    public List<ResourceSet> updateDocument(String projectName, ProjectStorage.ResourceType documentType,                                            String contents,                                            String lockingAuthorization) {        if (lockingAuthorization == null || !lockingAuthorization.equals(projectLocks.get(projectName))) {            throw new KlabAuthorizationException("cannot update project " + projectName + " without " +                    "locking" + " it first");        }        var pd = projectDescriptors.get(projectName);        if (pd == null || !(pd.storage instanceof FileProjectStorage)) {            throw new KlabIllegalStateException("Cannot update a document that is not stored on the " +                    "service's filesystem");        }        /*        file storage: modify as specified         */        List<Notification> notifications = new ArrayList<>();        var parsed = switch (documentType) {            case ONTOLOGY ->                    ontologyParser.parse(new StringReader(contents), notifications).getNamespace().getName();            case MODEL_NAMESPACE ->                    namespaceParser.parse(new StringReader(contents), notifications).getNamespace().getName();            //            case BEHAVIOR-> null; // TODO            case STRATEGY ->                    strategyParser.parse(new StringReader(contents), notifications).getPreamble().getName();            default -> throw new KlabUnimplementedException("parsing new " + documentType);        };        if (parsed != null) {            // do the update in the stored project and screw it            var url = ((FileProjectStorage) pd.storage).update(documentType, parsed, contents);            return handleFileChange(projectName,                    List.of(Triple.of(documentType, CRUDOperation.UPDATE, url)));        }        return List.of();    }    public List<ResourceSet> createDocument(String projectName, ProjectStorage.ResourceType documentType,                                            String documentUrn, String lockingAuthorization) {        List<ResourceSet> ret = new ArrayList<>();        if (lockingAuthorization == null || !lockingAuthorization.equals(projectLocks.get(projectName))) {            throw new KlabAuthorizationException("cannot update project " + projectName + " without " +                    "locking" + " it first");        }        var pd = projectDescriptors.get(projectName);        if (pd == null || !(pd.storage instanceof FileProjectStorage fileProjectStorage)) {            throw new KlabIllegalStateException("Cannot create a document within a project not stored on " +                    "the " +                    "service's filesystem");        }        var document = fileProjectStorage.create(documentUrn, documentType);        if (document != null) {            return handleFileChange(projectName,                    List.of(Triple.of(documentType, CRUDOperation.CREATE, document)));        }        return ret;    }}